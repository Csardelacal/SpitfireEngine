<?php namespace spitfire\model\query;

/*
 *
 * Copyright (C) 2023-2023 CÃ©sar de la Cal Bretschneider <cesar@magic3w.com>.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-13 01  USA
 *
 */

use PDOException;
use spitfire\collection\Collection;
use spitfire\collection\TypedCollection;
use spitfire\model\ActiveRecord;
use spitfire\model\Model;
use spitfire\model\relations\RelationshipInterface;
use spitfire\storage\database\identifiers\FieldIdentifierInterface;
use spitfire\storage\database\identifiers\IdentifierInterface;
use spitfire\storage\database\Record;

/**
 * 
 * @todo Add support for pivot tables (os sub-result mappings)
 * @todo Add documentation
 * @template T of Model
 */
class ResultSetMapping
{
	
	/**
	 * 
	 * @var T
	 */
	private Model $model;
	
	/**
	 *
	 * @var Collection<FieldIdentifierInterface>
	 */
	private $map;
	
	/**
	 * 
	 * @var string[]
	 */
	private $with = [];
	
	/**
	 * 
	 * @param T $model
	 */
	public function __construct(Model $model)
	{
		$this->model = $model;
		$this->map = new TypedCollection(FieldIdentifierInterface::class);
	}
	
	/**
	 * 
	 * @return T
	 */
	public function getModel()
	{
		return $this->model;
	}
	
	public function map(string $field) : IdentifierInterface
	{
		assert($this->map->has($field));
		return $this->map[$field];
	}
	
	/**
	 * 
	 * @param string $name
	 * @param FieldIdentifierInterface $field
	 * @return static
	 */
	public function set(string $name, FieldIdentifierInterface $field) : static
	{
		$this->map[$name] = $field;
		return $this;
	}
	
	/**
	 * 
	 * @param string[] $with
	 * @return static
	 */
	public function with(array $with) : ResultSetMapping
	{
		$copy = clone $this;
		$copy->with = $with;
		return $copy;
	}
	
	/**
	 * 
	 * @param Collection<array<string,mixed>> $data
	 * @return Collection<T>
	 */
	public function make(Collection $data) : Collection
	{
		
		/**
		 * The resultset mapper receives a raw array with data from the DBMS and creates
		 * active records out of them.
		 */
		$records = $data->each(function (array $raw) : Record {
			/**
			 * First, create a simple record. This is just a simple object that is aware of
			 * changes to it's content.
			 *
			 * @todo I would generally believe that it would be awesome if the record objects
			 * where generated by the Driver, instead of here.
			 */
			return new Record($raw);
		});
		
		$activeRecords = $records->each(function (Record $r) : ActiveRecord {
			return new ActiveRecord($this->model, $r->slice($this->makeFieldList()));
		});
		
		/**
		 * Eagerly load the relationships needed. Eager loading reduces overhead when multiple records
		 * are fetched from the database and they all need relationships resolved.
		 */
		!empty($this->with) && $this->eagerLoad($activeRecords);
		
		/**
		 * Once the records have been eagerly loaded, we can proceed to hydrate the models using them.
		 * 
		 * @var Collection<T>
		 */
		$models = $activeRecords->each(function (ActiveRecord $record) {
			return $this->model->withHydrate($record);
		});
		
		return $models;
	}
	
	/**
	 * @return T
	 */
	public function makeOne(Record $record) : Model
	{
		
		$activeRecord = new ActiveRecord($this->model, $record->slice($this->makeFieldList()));
		
		/**
		 * Eagerly load the relationships needed. Eager loading reduces overhead when multiple records
		 * are fetched from the database and they all need relationships resolved.
		 */
		!empty($this->with) && $this->eagerLoad(new Collection($activeRecord));
		
		/**
		 * Once the records have been eagerly loaded, we can proceed to hydrate the models using them.
		 * 
		 * @var T
		 */
		return $this->model->withHydrate($activeRecord);
		
	}
	
	/**
	 * The mapper must only extract the information it needs to assemble the model.
	 * For this, the fields retrieved from the query object need to be used to slice
	 * the record.
	 *
	 * @return string[]
	 */
	protected function makeFieldList() : array
	{
		return (($this->map))
			->each(fn (FieldIdentifierInterface $e) : string  => $e->getFieldName())
			->toArray();
	}
	
	/**
	 *
	 * @param Collection<ActiveRecord> $records
	 * @return Collection<ActiveRecord>
	 */
	protected function eagerLoad(Collection $records) : Collection
	{
		assert($records->containsOnly(ActiveRecord::class));
		
		foreach ($this->with as $relation) {
			$meta = $this->model->$relation();
			assert($meta instanceof RelationshipInterface);
			
			$children = $meta->resolveAll($records);
			
			foreach ($records as $record) {
				
				/**
				 * Our relationship is determined by the contents of the local field. This is also
				 * the one the system uses to organize the records by.
				 */
				$lookfor  = $record->getUnderlyingRecord()->get($meta->localField()->getName());
				
				assert(is_string($lookfor) || is_int($lookfor));
				
				/**
				 * If the relationship is not defined (and it's value is null) we tell the
				 * underlying application that it is indeed, null.
				 */
				if (!$children->has($lookfor)) {
					$record->set($relation, null);
				}
				else {
					/**@var $record Record */
					$record->set($relation, $children[$lookfor]);
				}
				
			}
		}
		
		return $records;
	}
}
