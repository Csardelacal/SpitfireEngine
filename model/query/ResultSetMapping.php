<?php namespace spitfire\model\query;

use spitfire\collection\Collection;
use spitfire\model\ActiveRecord;
use spitfire\model\Model;
use spitfire\model\relations\RelationshipInterface;
use spitfire\storage\database\identifiers\FieldIdentifierInterface;
use spitfire\storage\database\identifiers\IdentifierInterface;
use spitfire\storage\database\Record;

class ResultSetMapping
{
	
	private $model;
	
	private ?ResultSetMapping $pivot = null;
	
	/**
	 *
	 * @var IdentifierInterface[]
	 */
	private $map;
	
	private $with = [];
	
	public function __construct(Model $model)
	{
		$this->model = $model;
		$this->map = [];
	}
	
	public function getModel()
	{
		return $this->model;
	}
	
	public function map(string $field) : IdentifierInterface
	{
		assert(array_key_exists($field, $this->map));
		return $this->map[$field];
	}
	
	public function set(string $name, IdentifierInterface $field)
	{
		$this->map[$name] = $field;
		return $this;
	}
	
	public function with(array $with) : ResultSetMapping
	{
		$copy = clone $this;
		$copy->with = $with;
		return $copy;
	}
	
	public function withPivot(ResultSetMapping $pivot = null) : ResultSetMapping
	{
		/**
		 * If both are null, there's no point in doing anything.
		 */
		if ($this->pivot === null && $pivot === null) {
			return $this;
		}
		
		/**
		 * Having pivots that can pivot would cause infinite recursion. We do want
		 * to avoid that.
		 */
		assert($pivot->pivot === null);
		
		$copy = clone $this;
		$copy->pivot = $pivot;
		return $copy;
	}
	
	public function make(Collection $data) : Collection
	{
		
		/**
		 * The resultset mapper receives a raw array with data from the DBMS and creates
		 * active records out of them.
		 */
		$records = $data->each(function (array $raw) : Record {
			/**
			 * First, create a simple record. This is just a simple object that is aware of
			 * changes to it's content.
			 *
			 * @todo I would generally believe that it would be awesome if the record objects
			 * where generated by the Driver, instead of here.
			 */
			return new Record($raw);
		});
		
		$activeRecords = $records->each(function (Record $r) : ActiveRecord {
			return new ActiveRecord($this->model, $r->slice($this->makeFieldList()));
		});
		
		/**
		 * Eagerly load the relationships needed. Eager loading reduces overhead when multiple records
		 * are fetched from the database and they all need relationships resolved.
		 */
		!empty($this->with) && $this->eagerLoad($activeRecords);
		
		/**
		 * Once the records have been eagerly loaded, we can proceed to hydrate the models using them.
		 */
		$models = $activeRecords->each(function (ActiveRecord $record) {
			return $this->model->withHydrate($record);
		});
		
		/**
		 * In case the mapper has a pivot, now is the time to create it and attach it to the model.
		 */
		if (!empty($this->pivot)) {
			foreach ($records as $idx => $record) {
				$models[$idx]->setPivot($this->pivot->makeOne($record));
			}
		}
		
		return $models;
	}
	
	public function makeOne(Record $record) : Model
	{
		
		$activeRecord = new ActiveRecord($this->model, $record->slice($this->makeFieldList()));
		
		/**
		 * Eagerly load the relationships needed. Eager loading reduces overhead when multiple records
		 * are fetched from the database and they all need relationships resolved.
		 */
		!empty($this->with) && $this->eagerLoad(new Collection([$activeRecord]));
		
		/**
		 * Once the records have been eagerly loaded, we can proceed to hydrate the models using them.
		 */
		$model = $this->model->withHydrate($activeRecord);
		
		/**
		 * In case the mapper has a pivot, now is the time to create it and attach it to the model.
		 */
		if (!empty($this->pivot)) {
			$model->setPivot($this->pivot->makeOne($record));
		}
		
		return $model;
	}
	
	/**
	 * The mapper must only extract the information it needs to assemble the model.
	 * For this, the fields retrieved from the query object need to be used to slice
	 * the record.
	 *
	 * @return string[]
	 */
	protected function makeFieldList() : array
	{
		return (new Collection($this->map))
			->each(fn (FieldIdentifierInterface $e) : string  => $e->getFieldName())
			->toArray();
	}
	
	/**
	 *
	 * @param Collection<ActiveRecord> $records
	 */
	protected function eagerLoad(Collection $records) : Collection
	{
		assert($records->containsOnly(ActiveRecord::class));
		
		foreach ($this->with as $relation) {
			$meta = $this->model->$relation();
			assert($meta instanceof RelationshipInterface);
			
			$children = $meta->resolveAll($records);
			
			/**
			 * @todo This needs to make use of reflection so it can be used properly.
			 */
			foreach ($records as $record) {
				/**@var $record Record */
				$record->set($relation, $children[$record->getPrimary()]);
			}
		}
		
		return $records;
	}
}
