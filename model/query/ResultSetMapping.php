<?php namespace spitfire\model\query;

use spitfire\collection\Collection;
use spitfire\model\ActiveRecord;
use spitfire\model\Model;
use spitfire\model\relations\RelationshipInterface;
use spitfire\storage\database\identifiers\FieldIdentifierInterface;
use spitfire\storage\database\identifiers\IdentifierInterface;
use spitfire\storage\database\Record;

/**
 * 
 * @todo Add documentation
 */
class ResultSetMapping
{
	
	/**
	 * 
	 * @var Model
	 */
	private Model $model;
	
	/**
	 *
	 * @var IdentifierInterface[]
	 */
	private $map;
	
	/**
	 * 
	 * @var string[]
	 */
	private $with = [];
	
	/**
	 * 
	 * @param Model $model
	 */
	public function __construct(Model $model)
	{
		$this->model = $model;
		$this->map = [];
	}
	
	/**
	 * 
	 * @return Model
	 */
	public function getModel()
	{
		return $this->model;
	}
	
	public function map(string $field) : IdentifierInterface
	{
		assert(array_key_exists($field, $this->map));
		return $this->map[$field];
	}
	
	/**
	 * 
	 * @param string $name
	 * @param IdentifierInterface $field
	 * @return static
	 */
	public function set(string $name, IdentifierInterface $field) : static
	{
		$this->map[$name] = $field;
		return $this;
	}
	
	/**
	 * 
	 * @param string[] $with
	 * @return static
	 */
	public function with(array $with) : ResultSetMapping
	{
		$copy = clone $this;
		$copy->with = $with;
		return $copy;
	}
	
	/**
	 * 
	 * @param Collection<mixed[]> $data
	 * @return Collection<Model>
	 */
	public function make(Collection $data) : Collection
	{
		
		/**
		 * The resultset mapper receives a raw array with data from the DBMS and creates
		 * active records out of them.
		 */
		$records = $data->each(function (array $raw) : Record {
			/**
			 * First, create a simple record. This is just a simple object that is aware of
			 * changes to it's content.
			 *
			 * @todo I would generally believe that it would be awesome if the record objects
			 * where generated by the Driver, instead of here.
			 */
			return new Record($raw);
		});
		
		$activeRecords = $records->each(function (Record $r) : ActiveRecord {
			return new ActiveRecord($this->model, $r->slice($this->makeFieldList()));
		});
		
		/**
		 * Eagerly load the relationships needed. Eager loading reduces overhead when multiple records
		 * are fetched from the database and they all need relationships resolved.
		 */
		!empty($this->with) && $this->eagerLoad($activeRecords);
		
		/**
		 * Once the records have been eagerly loaded, we can proceed to hydrate the models using them.
		 * 
		 * @var Collection<Model>
		 */
		$models = $activeRecords->each(function (ActiveRecord $record) {
			return $this->model->withHydrate($record);
		});
		
		return $models;
	}
	
	public function makeOne(Record $record) : Model
	{
		
		$activeRecord = new ActiveRecord($this->model, $record->slice($this->makeFieldList()));
		
		/**
		 * Eagerly load the relationships needed. Eager loading reduces overhead when multiple records
		 * are fetched from the database and they all need relationships resolved.
		 */
		!empty($this->with) && $this->eagerLoad(new Collection([$activeRecord]));
		
		/**
		 * Once the records have been eagerly loaded, we can proceed to hydrate the models using them.
		 */
		return $this->model->withHydrate($activeRecord);
		
	}
	
	/**
	 * The mapper must only extract the information it needs to assemble the model.
	 * For this, the fields retrieved from the query object need to be used to slice
	 * the record.
	 *
	 * @return string[]
	 */
	protected function makeFieldList() : array
	{
		return (new Collection($this->map))
			->each(fn (FieldIdentifierInterface $e) : string  => $e->getFieldName())
			->toArray();
	}
	
	/**
	 *
	 * @param Collection<ActiveRecord> $records
	 * @return Collection<ActiveRecord>
	 */
	protected function eagerLoad(Collection $records) : Collection
	{
		assert($records->containsOnly(ActiveRecord::class));
		
		foreach ($this->with as $relation) {
			$meta = $this->model->$relation();
			assert($meta instanceof RelationshipInterface);
			
			$children = $meta->resolveAll($records);
			
			foreach ($records as $record) {
				
				/**
				 * Our relationship is determined by the contents of the local field. This is also
				 * the one the system uses to organize the records by.
				 */
				$lookfor  = $record->getUnderlyingRecord()->get($meta->localField()->getName());
				
				/**
				 * If the relationship is not defined (and it's value is null) we tell the
				 * underlying application that it is indeed, null.
				 */
				if (!$children->has($lookfor)) {
					$record->set($relation, null);
				}
				else {
					/**@var $record Record */
					$record->set($relation, $children[$lookfor]);
				}
				
			}
		}
		
		return $records;
	}
}
