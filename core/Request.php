<?php namespace spitfire\core;

use magic3w\http\url\reflection\URLReflection;
use spitfire\exceptions\ApplicationException;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\StreamInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Message\UploadedFileInterface;
use spitfire\core\http\request\components\hasBody;
use spitfire\core\http\request\components\hasHTTPMethod;
use spitfire\core\http\request\components\hasParsedBody;
use spitfire\core\http\request\components\hasProtocolVersion;
use spitfire\core\http\request\components\hasServerParams;
use spitfire\core\http\request\components\hasUploads;
use spitfire\core\http\request\components\hasURI;
use spitfire\io\stream\Stream;
use spitfire\io\UploadFile;

/*
 * Copyright (C) 2021 CÃ©sar de la Cal Bretschneider <cesar@magic3w.com>.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
/**
 * The request class is a component that allows developers to retrieve information
 * about data that usually is delivered by the webserver. For example, get and
 * post data are usually stored by this object in order to allow your app to
 * use it.
 */
class Request implements ServerRequestInterface
{
	use
	hasProtocolVersion,
	hasHTTPMethod,
	hasURI,
	hasServerParams,
	hasUploads,
	hasParsedBody,
	hasBody;
	
	/**
	 *
	 * @var mixed
	 */
	private $attributes;
	
	/**
	 * Allows your app to maintain a copy of the COOKIE variable. This is especially
	 * useful when writing tests considering different requests as you will easily
	 * be able to swap the values.
	 *
	 * @var mixed
	 */
	private $cookie;
	
	/**
	 * This object allows your app to conveniently access the HTTP headers. These
	 * will contain information like DNT or User agent that can be relevant to your
	 * application and alter the experience the user receives.
	 *
	 * @var Headers
	 */
	private Headers $headers;
	
	/**
	 * Creates a new Request. This object 'simulates' a link between the user and
	 * the Application. It allows you to retrieve the data the user has sent with
	 * the Request and therefore adapt the behavior of your application accordingly.
	 *
	 * [Notice] This function does NOT validate the data it receives and assumes
	 * it is correct. This is due to this code being executed every single time
	 * your app is invoked and therefore being required to be lightweight.
	 *
	 * @param string                  $method
	 * @param UriInterface            $uri
	 * @param Headers                 $headers
	 * @param string[]                $cookies
	 * @param string[]                $serverParams
	 * @param StreamInterface         $body
	 * @param UploadedFileInterface[] $uploads
	 */
	public function __construct(
		string $method,
		UriInterface $uri,
		Headers $headers,
		$cookies,
		array $serverParams,
		StreamInterface $body,
		array $uploads
	) {
		#Import the data generated by external systems.
		$this->serverParams = $serverParams;
		$this->uri      = $uri;
		$this->body     = $body;
		$this->cookie   = $cookies;
		$this->headers  = $headers;
		$this->method   = $method;
		$this->uploads  = $uploads;
	}
	
	/**
	 *
	 * @return mixed[]
	 */
	public function getAttributes()
	{
		return $this->attributes;
	}
	
	public function getAttribute($name, $default = null)
	{
		return array_key_exists($name, $this->attributes)? $this->attributes[$name] : $default;
	}
	
	/**
	 *
	 * @return string[]
	 */
	public function getCookieParams()
	{
		return $this->cookie;
	}
	
	public function getHeaders()
	{
		return $this->headers->all();
	}
	
	public function withProtocolVersion($version)
	{
		$copy = clone $this;
		$copy->version = $version;
		
		return $copy;
	}
	
	/**
	 * Override a single attribute that the server received. Please note that
	 * this method does not support nested access, so you cannot override a
	 * key in a nested attribute.
	 *
	 * @return ServerRequestInterface
	 */
	public function withAttribute($name, $value)
	{
		$copy = clone $this;
		$copy->attributes[$name] = $value;
		return $copy;
	}
	
	
	/**
	 *
	 * @param string $name
	 * @return bool
	 */
	public function hasHeader($name): bool
	{
		return !empty($this->headers->get($name));
	}
	
	/**
	 *
	 * @param string $name
	 * @return string[]
	 */
	public function getHeader($name)
	{
		return $this->headers->get($name);
	}
	
	/**
	 * The header line represents the data that is being sent to the browser, some headers
	 * allow sending multiple values, separated by commas, which the client cannot receive
	 * unless we convert our arrays in comma separated strings.
	 *
	 * @param string $name
	 * @return string
	 */
	public function getHeaderLine($name): string
	{
		$header = $this->headers->get($name);
		
		if (empty($header)) {
			return implode(',', $header);
		}
		else {
			return '';
		}
	}
	
	/**
	 * Returns a copy of the response, with the header that the user has added.
	 *
	 * @param string $name
	 * @param string|string[] $value
	 * @return Request
	 */
	public function withHeader($name, $value): Request
	{
		$headers = clone $this->headers;
		$headers->set($name, (array)$value);
		
		$copy = clone $this;
		$copy->headers = $headers;
		return $copy;
	}
	
	/**
	 * Returns a copy of the response, but with additional information on a header,
	 * which allows the user to push data onto the header.
	 *
	 * @param string $name
	 * @param string|string[] $value
	 * @return Request
	 */
	public function withAddedHeader($name, $value): Request
	{
		$headers = clone $this->headers;
		$headers->addTo($name, (array)$value);
		
		$copy = clone $this;
		$copy->headers = $headers;
		return $copy;
	}
	
	/**
	 * Returns a copy of the response, without the given header.
	 *
	 * @param string $name
	 * @return Request
	 */
	public function withoutHeader($name): Request
	{
		$headers = clone $this->headers;
		$headers->unset($name);
		
		$copy = clone $this;
		$copy->headers = $headers;
		return $copy;
	}
	
	/**
	 * Removes the attribute from the request.
	 *
	 * @return Request
	 */
	public function withoutAttribute($name)
	{
		$copy = clone $this;
		unset($copy->attributes[$name]);
		return $copy;
	}
	
	/**
	 *
	 * @param string[] $cookies
	 */
	public function withCookieParams(array $cookies)
	{
		$copy = clone $this;
		$copy->cookie = $cookies;
		return $copy;
	}
	
	/**
	 * If the request contains range information (the client only wishes to retrieve a subset of the
	 * resource), this endpoint will return true.
	 *
	 * @return bool
	 */
	public function isRange() : bool
	{
		return !empty($this->headers->get('Range'));
	}
	
	/**
	 * For ranged requests, this function provides a convenience access to the range data.
	 * This method only supports ranges in Bytes
	 *
	 * @return array{int,int|null}
	 */
	public function getRange() : array
	{
		$sent = $this->headers->get('Range')[0];
		
		if (!\spitfire\utils\Strings::startsWith($sent, 'bytes=')) {
			throw new ApplicationException('Malformed range sent', 416);
		}
		
		if (strstr($sent, ',')) {
			throw new ApplicationException('Spitfire does not accept multiple ranges', 416);
		}
		
		$pieces = explode('-', substr($_SERVER['HTTP_RANGE'], 6));
		
		return [
			(int)array_shift($pieces),
			(int)array_shift($pieces)?: null
		];
	}
	
	/**
	 * Extract a request object from the current SAPI request. This distills the
	 * context of the global request into an object that we can manipulate as we
	 * descent into the middleware and request handler stack.
	 *
	 * @return Request
	 */
	public static function fromGlobals() : Request
	{
		
		/**
		 * Extract the method from Globals. Allowing our application to respond in different manners
		 * if we so desire.
		 */
		$method = self::methodFromGlobals();
		
		/**
		 * The headers have their own little helper function that calls the apache_get_all_headers
		 * function. Counter-intuitively, this function also works in CLI, FastCGI and NginX
		 */
		$headers = Headers::fromGlobals();
		
		/**
		 * The URI is assembled by the URLReflection class.
		 */
		$uri = URLReflection::fromGlobals();
		
		$uploads = self::filesFromGlobals();
		
		/**
		 * The PSR strongly suggests that both the cookie and server variable should be directly
		 * read from the webserver.
		 */
		$cookies = $_COOKIE;
		$serverParams = $_SERVER;
		
		/**
		 * Open the body as a stream. In get requests this stream will contain nothing (obviously),
		 * but all other requests will be able to read data from this.
		 *
		 * Please note that this doesn't apply to simulated get requests, where the client requested
		 * the data to be treated as POST.
		 */
		$body = new Stream(fopen('php://input', 'r'), true, true, false);
		
		$request = new Request($method, $uri, $headers, $cookies, $serverParams, $body, $uploads);
		
		/**
		 * We default to assuming that the content type is undefined, and then loop over the
		 * headers to attempt and find a header that overrides this.
		 */
		$contentType = null;
		
		/**
		 * Loop over the content-type headers available (spoiler, it's only one) and extract the content
		 * type. Since the content type can be followed by a semicolon to add boundary information and
		 * charset information, we just parse the very first bit containing the mime type of the payload.
		 */
		foreach ($headers->get('content-type')?: [] as $_h) {
			$contentType = explode(';', $_h)[0];
		}
		
		/**
		 * If the sender is transmitting content that we understand, use it. This implies that the request
		 * gets parsed if the CLIENT sent a POST request, regardless of how the request was overridden,
		 * it also does this when the method is set to something manually that expects a parsed body.
		 */
		if (in_array($contentType, ['multipart/formdata', 'application/x-www-form-urlencoded'])) {
			$request->withParsedBody($_POST);
		}
		elseif ($contentType === 'application/json') {
			$request->withParsedBody(json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR));
		}
		
		return $request;
	}
}
